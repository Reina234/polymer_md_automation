import numpy as np


class PolymerMoltemplateGenerator:
    """
    Generates the Moltemplate molecule definition for a linear polymer of length N
    (one bead per monomer). Explicitly defines bonds and angles for consecutive
    monomers.
    """

    def __init__(self, N):
        self.N = N  # number of monomers (beads)

    def generate_polymer_molecule_block(self, name="Polymer"):
        """
        Returns a string defining a 'Molecule' block in Moltemplate language.
        We place each bead along x in increments of 1.0, for example.
        We create consecutive bonds (i-i+1) and angles (i-i+1-i+2).
        """
        lines = []
        lines.append(f"Molecule {name} {{")

        # -- ATOMS: $atom: bead_i x y z --
        # We'll place them along x-axis for convenience:
        for i in range(self.N):
            x_coord = float(i)  # spacing of 1.0 along x
            lines.append(f"  $atom:bead_{i+1} {x_coord} 0.0 0.0")

        lines.append("")  # blank line for clarity

        # -- BONDS: consecutive pairs (1–2, 2–3, ..., N-1–N) --
        for i in range(self.N - 1):
            i1 = i + 1
            i2 = i + 2
            lines.append(f"  bond:bond_{i1}_{i2} @atom:bead_{i1} @atom:bead_{i2}")

        lines.append("")

        # -- ANGLES: consecutive triplets (1–2–3, 2–3–4, ...) --
        for i in range(self.N - 2):
            i1 = i + 1
            i2 = i + 2
            i3 = i + 3
            lines.append(
                f"  angle:angle_{i1}_{i2}_{i3} @atom:bead_{i1} @atom:bead_{i2} @atom:bead_{i3}"
            )

        lines.append("}")  # end of Molecule block
        return "\n".join(lines)


class SolventMoltemplateGenerator:
    """
    Simple class defining a single-bead solvent molecule.
    """

    def generate_solvent_molecule_block(self, name="Solvent"):
        """
        One bead at (0,0,0). No bonds or angles needed.
        """
        return f"Molecule {name} {{\n" f"  $atom:S 0.0 0.0 0.0\n" f"}}\n"


class IonMoltemplateGenerator:
    """
    Simple class defining a single-bead ion molecule.
    """

    def generate_ion_molecule_block(self, name="Ion"):
        """
        One bead at (0,0,0). No bonds or angles needed.
        """
        return f"Molecule {name} {{\n" f"  $atom:I 0.0 0.0 0.0\n" f"}}\n"


class MoltemplateSystemBuilder:
    """
    Manages creation of:
      - A polymer molecule (with bonds/angles)
      - Solvent and ion molecules
      - Instances of these molecules placed in the simulation box
      - Writes out a moltemplate 'system.lt' file.
    """

    def __init__(self, N, box, solvent_positions, ion_positions):
        """
        N                : Number of polymer beads
        box              : (x_min, x_max, y_min, y_max, z_min, z_max)
        solvent_positions: List of (x,y,z)
        ion_positions    : List of (x,y,z)
        """
        self.N = N
        self.box = box
        self.solvent_positions = solvent_positions
        self.ion_positions = ion_positions

        # Instantiate the sub-generators
        self.poly_gen = PolymerMoltemplateGenerator(N)
        self.solv_gen = SolventMoltemplateGenerator()
        self.ion_gen = IonMoltemplateGenerator()

    def write_system_lt(self, filename="system.lt"):
        """
        Writes out a system.lt file containing:
          1) Forcefield import statement (adjust path if needed)
          2) Polymer, Solvent, Ion molecule definitions
          3) Single polymer instance (translated to center of box)
          4) Many solvent bead instances
          5) Many ion bead instances
        """
        # Unpack the box
        x_min, x_max, y_min, y_max, z_min, z_max = self.box
        x_center = 0.5 * (x_min + x_max)
        y_center = 0.5 * (y_min + y_max)
        z_center = 0.5 * (z_min + z_max)

        polymer_def = self.poly_gen.generate_polymer_molecule_block(name="Polymer")
        solvent_def = self.solv_gen.generate_solvent_molecule_block(name="Solvent")
        ion_def = self.ion_gen.generate_ion_molecule_block(name="Ion")

        with open(filename, "w") as f:
            f.write("# Moltemplate system file (generated by Python)\n")
            # 1) Forcefield import (adjust if you have a custom FF file)
            f.write('import "forcefield.lt"\n\n')

            # 2) Molecule definitions
            f.write(polymer_def + "\n\n")
            f.write(solvent_def + "\n")
            f.write(ion_def + "\n")

            # 3) Create polymer instance in the center of the box
            f.write("new Polymer polymer_instance {\n")
            f.write(f"  translate {x_center} {y_center} {z_center}\n")
            f.write("}\n\n")

            # 4) Create solvent bead instances
            for i, pos in enumerate(self.solvent_positions):
                px, py, pz = pos
                f.write(f"new Solvent solvent_{i+1} {{ translate {px} {py} {pz} }}\n")

            f.write("\n")

            # 5) Create ion bead instances
            for j, pos in enumerate(self.ion_positions):
                px, py, pz = pos
                f.write(f"new Ion ion_{j+1} {{ translate {px} {py} {pz} }}\n")

            # (Optionally, store some extra info about the box)
            f.write(
                "\n# Box: xlo xhi: {} {}, ylo yhi: {} {}, zlo zhi: {} {}\n".format(
                    x_min, x_max, y_min, y_max, z_min, z_max
                )
            )

        print(f"Moltemplate system file '{filename}' generated successfully.")


# -----------------------------
# Support Functions for Solvent/Ion placement and Overlap
# -----------------------------
def create_solvent_grid(box, spacing):
    """
    Creates a regular grid of coordinates in the specified box.
    box = (x_min, x_max, y_min, y_max, z_min, z_max)
    """
    x_min, x_max, y_min, y_max, z_min, z_max = box
    x_coords = np.arange(x_min, x_max, spacing)
    y_coords = np.arange(y_min, y_max, spacing)
    z_coords = np.arange(z_min, z_max, spacing)

    grid_positions = []
    for x in x_coords:
        for y in y_coords:
            for z in z_coords:
                grid_positions.append((x, y, z))
    return grid_positions


def remove_overlaps(solvent_coords, polymer_coords, cutoff):
    """
    Remove solvent positions that are within 'cutoff' distance of any polymer bead.
    """
    filtered = []
    for s in solvent_coords:
        sx, sy, sz = s
        too_close = False
        for p in polymer_coords:
            px, py, pz = p
            dx = sx - px
            dy = sy - py
            dz = sz - pz
            if (dx * dx + dy * dy + dz * dz) < (cutoff * cutoff):
                too_close = True
                break
        if not too_close:
            filtered.append(s)
    return filtered


def add_ions(polymer_net_charge, box, ion_spacing):
    """
    Generate ion positions to neutralize the polymer, picking from a grid.
    """
    num_ions = abs(polymer_net_charge)
    all_ions = create_solvent_grid(box, ion_spacing)
    ions = all_ions[:num_ions]  # pick as many as needed
    return ions


# -----------------------------
# Main driver
# -----------------------------
def main():
    """
    Example usage:
      - Creates a polymer with N=10 monomers
      - Generates a large cubic box
      - Places solvent and ions on a grid (with overlap removal)
      - Writes a moltemplate 'system.lt' with explicit polymer bonds/angles
    """
    # Parameters
    N = 10
    box = (-20.0, 20.0, -20.0, 20.0, -20.0, 20.0)
    solvent_spacing = 2.0
    ion_spacing = 5.0
    overlap_cutoff = 1.5
    polymer_net_charge = -5  # example charge

    # 1) Generate approximate polymer coordinates along x
    polymer_coords = []
    for i in range(N):
        polymer_coords.append((float(i), 0.0, 0.0))  # 1.0 spacing

    # Center the polymer
    x_min, x_max, y_min, y_max, z_min, z_max = box
    x_center = 0.5 * (x_min + x_max)
    y_center = 0.5 * (y_min + y_max)
    z_center = 0.5 * (z_min + z_max)
    polymer_coords_centered = [
        (p[0] + x_center, p[1] + y_center, p[2] + z_center) for p in polymer_coords
    ]

    # 2) Generate solvent grid and remove overlaps
    solvent_grid = create_solvent_grid(box, solvent_spacing)
    solvent_filtered = remove_overlaps(
        solvent_grid, polymer_coords_centered, overlap_cutoff
    )

    # 3) Generate ion positions
    ion_positions = add_ions(polymer_net_charge, box, ion_spacing)

    # 4) Build the system.lt file using our class approach
    builder = MoltemplateSystemBuilder(N, box, solvent_filtered, ion_positions)
    builder.write_system_lt(filename="system.lt")


if __name__ == "__main__":
    main()
